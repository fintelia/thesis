\noindent
Side channel attacks leak information between isolation domains outside of the normal information flow of a system.
Several years ago a new class of side channel attacks was discovered impacting CPUs from all major vendors~\cite{lipp:meltdown, kocher:spectre}.
These attacks -- termed transient execution attacks -- exploit details of how modern processors use speculative execution to run more quickly. 

Transient execution attacks represent a concern for operating system developers because a key security responsibility for operating systems is to maintain isolation.
In particular, multiple processes running on the same machine must not inadvertently leak information between one another.
Production operating systems and other software vendors have deployed a range of software techniques devised to mitigate the impact of these attacks, but unfortunately they can introduce significant performance trade offs.

The overhead caused by these mitigations is present on the many hundreds of millions vulnerable processors dating from before the discovery of the attacks, and also at least to some degree on all major commercial CPUs released after their discovery.
This thesis both attempts to quantify how this overhead has evolved over subsequent generations of processors and presents an operating system design to reduce OS level overheads on the CPUs where they are most severe.  

% Many hundreds of millions of vulnerable computer processors are currently in use, so simply replacing them all isn’t by itself a viable solution.
% Worse still, computer architectural approaches to solve transient execution attacks remains an open area of research, except on the simplest of processors.

% Nonetheless, generations of processors designed after the discovery of transient execution attacks have improvements that make them inherently less susceptible to attack.
% It is desirable to understand how this was achieved yet little has been published on exactly what changes were made.
% The focus of this thesis is on understanding and reducing the impact of mitigations on performance.

\section{Transient Execution Attacks}
\subsection{Speculative Execution}
Speculative execution is an optimization used in the design of modern processors to drastically improve their performance, by enabling them to do useful work during times when they would otherwise be stalled waiting to load information from RAM.
When the CPU reaches a conditional branch instruction that it doesn't yet know whether will be taken or not, it predicts the outcome and then starts executing instructions that would follow.
The prediction is based on prior executions of that same instructions and any other heuristics the processor may have.

Usually the branch prediction is correct and the speculatively executed instructions can be committed.
However, when the prediction is incorrect, the CPU rolls back the architecturally visible results of the instructions executed after the branch.
In general when reverting transiently executed instructions, their microarchitural effects -- like inserting or evicting lines from the cache -- are not undone.
Observing the  microarchitural effects of speculatively executed instructions is the core of transient execution attacks.

\subsection{Example Attack}
\begin{figure}[h]
\begin{lstlisting}[language=C, style=codeStyle]
if (index < array_size) {
    int v = array2[array1[index] * 256];
    ...
}
\end{lstlisting}
\caption{Example code for a Spectre V1 attack}
\label{fig:spectre-code}
\end{figure}
Spectre V1 was one of the earliest attacks discovered and leaks information between different processes, between a process and the operating system kernel, or between a sandbox and the code running within.
The attack relies on a specific sequence of instructions (a ``gadget'') to be located in the victim's code region.
The gadget consists of a bounds check followed by two array accesses as shown in Figure~\ref{fig:spectre-code}, for which the index value can be controlled by the adversary.

To trigger the attack, the adversary will repeatedly call the gadget with in bounds indexes.
This will train the CPU branch predictor that the branch is usually taken.
Then, the attackers forces the array size to be evicted from the CPU cache and calls the gadget with an out of bounds index.

When execution reaches the bounds check, the processor will initiate a load to read the array size.
However before that load completes, the CPU will speculatively start executing the body of the if statement because the branch predictor has previously learned that the index is usually in bounds.
The first array access will read past the end of the array into arbitrary memory and pull that value into a CPU register.
The second array access then loads a specific cache line whose index will depend on the first read.

Eventually the branch misprediction will be discovered and rolled back, but the cache contents will not be.
This enables the attacker to later time how long it takes to access each cache entry and infer which value must have been pulled in by the victim application.

\subsection{Other Attacks}
There are a whole range of other transient execution attacks which can be divided into three categories~\cite{hill:survey}.
Spectre type attacks like the one described above rely on processor misprediction to incompletely roll back executed instructions.
Meanwhile Meltdown type attacks achieve the same effect using a trapping operation to trigger the roll back.
Finally, Microarchitural Data Sampling exploits the processor's forwarding logic to cause the processor to erroneously run instructions with data fed from a sibling hyperthead or previously running task, rather than the correct values.

\section{Mitigation Approaches}

There are two main approaches to preventing these attacks: either by modifying software, or altering the CPU design.

\noindent\textbf{Software:}
As the embargo period wound down on the original Meltdown and Spectre attacks, operating system vendors and processor makers hurriedly rolled out patches to mitigate these vulnerabilities.
The patches came at a significant performance cost. 

These fixes took two forms.
Hardware vendors released microcode patches for existing processors which modified behavior and added some new functionality to control speculative execution~\cite{intel:l1tf}.
Meanwhile, operating system makers and other software vendors deployed new versions which blocked the attacks via a combination of software only techniques~\cite{intel:retpoline, linux:kpti} and leveraging the functionality added by microcode~\cite{intel:l1tf}.

\noindent\textbf{Hardware:}
Software and microcode approaches to preventing transient execution attacks are severely constrained compared to what is possible by modifying CPU designs themselves.
For some attacks, straightforward architectural changes completely eliminate the vulnerability with almost no performance overhead and are already deployed in commercially available CPUs.
For other attacks, performant hardware mitigations remain an active area of research~\cite{OISA, ConTExT}.

\section{Evolution of Mitigation Cost}
Mitigations for transient execution attacks can introduce significant performance impacts.
For instance, the patches to mitigate Meltdown cause system calls to be up to 8$\times$ slower, while flushing microarchitural buffers to avoid MDS can add thousands of cycles to every context switch.
One goal of this thesis is to gain a detailed understand of how much cost the various mitigations incur across vendors and generations of processors.

We survey the cost of mitigations across multiple processor generations and across the two main vendors for x86 processors.
This enables us to understand both which costs are specific only to CPUs from a particular vendor as well as see trends in how costs are changing over time.

%The first contribution of this thesis is quantify the performance cost of hardware mitigations changes made in response to the attacks across successive generations of processors designed both before and after the publication of these attacks.

First, we run end-to-end benchmarks on each system measuring operating system and web-browser workloads.
This is enough to derive some high level trends and get a sense for the cost of the configurable mitigations on each system.
Our test systems vary on many dimensions unrelated to transient execution attacks (like core count, clock speed, and cache size) so our direct comparisons primary focus on relative differences between configurations of the same system.

On workloads that stress the Linux kernel interface (which have received the most attention) we find there have been substantial improvements with overheads on LEBench going from over 30\% to less than 3\%.
By contrast, the performance of JavaScript applications running inside Firefox are impacted by an almost entirely different set of mitigations, which on the Octane 2 JavaScript benchmark has caused overhead to remain roughly flat at 20\%. 


The bulk of our work is a detailed breakdown of individual attacks where we can investigate precise cycle costs.
For each mitigation identified by the end-to-end benchmarks, we attempt to measure execution time of the associated instruction or instruction sequence on each of our impacted systems.
Our experiments show meaningful variations between processors in how long individual mitigations take, and demonstrate that some of the most costly are completed avoided on the newest CPUs. 
The outcome of this investigation explains why overheads to prevent transient execution attacks have significantly declined for some workloads: the overhead of the different software mitigations haven't changed much but the improvements are explained by hardware changes that removed the need for a few of the most expensive mitigations.

\section{Ward}
For processors which currently require expensive operating system level software mitigations, we present \sys, an operating system architecture which achieves similar security guarantees to traditional OSes equiped with those mitigations but incurs substantially lower overhead.
%Ward particularly identifies KPTI~\cite{linux:kpti} (Linux's chosen defense against Meltdown) as a key source of overhead.
\sys has a novel operating system architecture which is resilient to transient execution attacks, yet avoids many of the expensive software mitigations that existing operating systems employ when running on older processors. 

In \sys, the operating system kernel is divided into multiple domains.
The K-domain includes all information accessible to the operation system, while each process has its own associated Q-domain consisting only of the userspace memory and kernel space data structures related to that one process.
At any given point in time the processor is either executing in userspace, in a Q-domain, or in the K-domain. 

Notably when executing in a Q-domain, \sys is able to avoid many of the expensive software mitigations that would ordinarily be required by a conventional OS when running in kernel mode on processors vulnerable to Spectre and Meltdown.
And since \sys is able to handle many system calls and traps entirely in the Q-domain, it can achieve considerably better performance on many workloads compared to conventional operating system designs.

\section{Contributions}

One primary contribution of this work is to draw attention to the
performance critical areas for improving transient execution
mitigations, driven by (1) an end-to-end survey of how mitigation
costs have evolved over processor generations, and (2) detailed
microbenchmarking of individual mitigations.  To analyze hardware
mitigations for Spectre V2, this thesis also contributes a new technique to measure
speculation using ideas from Bölük~\cite{speculating-x86}.

Another contribution is articulating the Unmapped Speculation Contract, which describes upper limits of what speculative execution attacks can and cannot do.
This thesis then demonstrates the benefits of the unmapped speculation contract
by presenting \sys{}, a novel kernel architecture that uses
selective kernel memory mapping to avoid some costly transient execution
mitigations.

\section{Outline}
The following chapter presents an end-to-end performance evaluation, and then goes into detail on each major attack describing both background on how it works as well as analyzing its impact on each evaluated system.
We then proceed to introduce the Unmapped Speculation Contract which encapsulates some security guarantees that we believe even old/vulnerable processors are able to provide, and describe the \sys kernel design that is able to leverage it to improve the performance of OS intensive workloads.
Afterwards is an overview of related work in this space.
We follow up with some discussion, some ideas for future work, and then conclude.
