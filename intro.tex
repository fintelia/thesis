\noindent
Side channel attacks leak information between isolation domains outside of the normal information flow of a system.
Several years ago a new class of side channel attacks was discovered impacting CPUs from all major vendors~\cite{lipp:meltdown, kocher:spectre}.
These attacks -- termed transient execution attacks -- exploit details of how modern processors use speculative execution to run more quickly. 

Transient execution attacks represent a concern for operating system developers because a key security responsibility for operating systems is to maintain isolation.
In particular, multiple processes running on the same machine must not inadvertently leak information between one another.
Production operating systems and other software vendors have deployed a range of software techniques devised to mitigate the impact of these attacks, but unfortunately they introduce significant performance trade offs.

The overhead caused by these mitigations is present on the many hundreds of millions vulnerable processors dating from before the discovery of the attacks, and also at least to some degree on all major commercial CPUs released after their discovery.
This thesis both attempts to quantify how this overhead has evolved over subsequent generations of processors and presents an operating system design to reduce OS level overheads on the CPUs where they are most severe.  

% Many hundreds of millions of vulnerable computer processors are currently in use, so simply replacing them all isnâ€™t by itself a viable solution.
% Worse still, computer architectural approaches to solve transient execution attacks remains an open area of research, except on the simplest of processors.

% Nonetheless, generations of processors designed after the discovery of transient execution attacks have improvements that make them inherently less susceptible to attack.
% It is desirable to understand how this was achieved yet little has been published on exactly what changes were made.
% The focus of this thesis is on understanding and reducing the impact of mitigations on performance.

\section{Transient Execution Attacks}
\subsection{Speculative Execution}
Speculative execution is an optimization used in the design of modern processors to drastically improve their performance, by enabling them to do useful work during times when they would otherwise be stalled waiting to load information from RAM.
When the CPU reaches a conditional branch instruction that it doesn't yet know whether will be taken or not, it predicts the outcome and then starts executing instructions that would follow.
The prediction is based on prior executions of that same instructions and any other heuristics the processor may have.

Usually the branch prediction is correct and the speculatively executed instructions can be committed.
However, when the prediction is incorrect, the CPU rolls back the architecturally visible results of the instructions executed after the branch.
In general when reverting transiently executed instructions, their microarchitural effects -- like inserting or evicting lines from the cache -- are not undone.
Observing the  microarchitural effects of speculatively executed instructions is the core of transient execution attacks.

\subsection{Example Attack}
\begin{figure}[h]
\begin{lstlisting}[language=C, style=codeStyle]
if (index < array_size) {
    int v = array2[array1[index] * 256];
    ...
}
\end{lstlisting}
\caption{Example code for a Spectre V1 attack}
\label{fig:spectre-code}
\end{figure}
Spectre V1 was one of the earliest attacks discovered and leaks information between different processes, between a process and the operating system kernel, or between a sandbox and the code running within.
The attack relies on a specific sequence of instructions (a ``gadget'') to be located in the victim's code region.
The gadget consists of a bounds check followed by two array accesses as shown in Figure~\ref{fig:spectre-code}, for which the index value can be controlled by the adversary.

To trigger the attack, the adversary will repeatedly call the gadget with in bounds indexes.
This will train the CPU branch predictor that the branch is usually taken.
Then, the attackers forces the array size to be evicted from the CPU cache and calls the gadget with an out of bounds index.

When execution reaches the bounds check, the processor will initiate a load to read the array size.
However before that load completes, the CPU will speculatively start executing the body of the if statement because the branch predictor has previously learned that the index is usually in bounds.
The first array access will read past the end of the array into arbitrary memory and pull that value into a CPU register.
The second array access then loads a specific cache line whose index will depend on the first read.

Eventually the branch misprediction will be discovered and rolled back, but the cache contents will not be.
This enables the attacker to later time how long it takes to access each cache entry and infer which value must have been pulled in by the victim application.

\subsection{Other Attacks}
There are a whole range of other transient execution attacks which can be divided into three categories~\cite{hill:survey}.
Spectre type attacks like the one described above rely on processor misprediction to incompletely roll back executed instructions.
Meanwhile Meltdown type attacks achieve the same effect using a trapping operation to trigger the roll back.
Finally, Microarchitural Data Sampling exploits the processor's forwarding logic to cause the processor to erroneously run instructions with data fed from a sibling hyperthead or previously running task, rather than the correct values.

\section{Mitigation Approaches}
\subsection{Software}
As the embargo period wound down on the original Meltdown and Spectre attacks, operating system vendors and processor makers hurriedly rolled out patches to mitigate these vulnerabilities.
The patches came at a significant performance cost. 

These fixes took two forms.
Hardware vendors released microcode patches for existing processors which modified behavior and added some new functionality to control speculative execution~\cite{intel:l1tf}.
Meanwhile, operating system makers and other software vendors deployed new versions which blocked the attacks via a combination of software only techniques~\cite{intel:retpoline, linux:kpti} and leveraging the functionality added by microcode~\cite{intel:l1tf}.

\subsection{Hardware}
Software and microcode approaches to preventing transient execution attacks are severely constrained compared to what is possible by modifying CPU designs themselves.
For some attacks, straightforward architectural changes completely eliminate the vulnerability with almost no performance overhead and are already deployed in commercially available CPUs.
For other attacks, performant hardware mitigations remain an active area of research~\cite{OISA, ConTExT}.

\section{Motivation and Approach}
Mitigations for transient execution attacks can introduce significant performance impacts.
For instance, the KAISER patches to mitigate Meltdown cause system calls to be up to 8$\times$ slower, while flushing microarchitural buffers to avoid MDS can add thousands of cycles to every context switch.
The goal of this thesis is to gain a detailed understand of how much cost the various mitigations incur across vendors and generations of processors, and to suggest ways to lessen the impact where it is most substantial.

The first contribution of this thesis is quantify the performance cost of hardware mitigations changes made in response to the attacks across successive generations of processors designed both before and after the publication of these attacks.
On workloads that stress the Linux kernel interface (which have received the most attention) there have been substantial improvements with slowdowns on LEBench going from over 30\% to less than 3\%.
By contrast, the overhead for JavaScript applications running inside
Firefox are impacted by an almost entirely different set of
mitigations.
On Octane 2, overhead has remained roughly flat at 20\%.
The overhead of software mitigations hasn't changed much,
but hardware changes that removed the need for a
few of the most expensive mitigations have significantly reduced overhead on some workloads.

% The insights from this analysis indicate that the most expensive mitigations are no longer required, and that while new attacks continue to be discovered, the overall performance impact of these new attacks has so far been significantly less severe.

Secondly, for processors which currently require expensive operating system level software mitigations, we present Ward, an operating system architecture which achieves similar security guarantees to traditional OSes equiped with those mitigations but incurs substantially lower overhead. Ward particularly identifies KPTI~\cite{linux:kpti} (Linux's chosen defense against Meltdown) as a key source of overhead.

\section{Evolution of Mitigation Cost}
We survey the cost of mitigations across multiple processor generations and across the two main vendors for x86 processors.
This enables us to understand both which costs are specific only to CPUs from a particular vendor as well as see trends in how costs are changing over time.

First, we run end-to-end benchmarks on each system measuring operating system and web-browser workloads.
This is enough to derive some high level trends and get a sense for the cost of the configurable mitigations on each system.
Our test systems vary on many dimensions unrelated to transient execution attacks (like core count, clock speed, and cache size) so our direct comparisons primary focus on relative differences between configurations of the same system.

The bulk of our work is a detailed breakdown of individual attacks where we can investigate precise cycle costs.
For each mitigation identified by the end-to-end benchmarks, we attempt to measure execution time of the associated instruction or instruction sequence on each of our impacted systems.
Our experiments show meaningful variations between processors in how long individual mitigations take, and demonstrate that some of the most costly are completed avoided on the newest CPUs. 
The outcome of this investigation explains why overheads to prevent transient execution attacks have significantly declined for some workloads.

\section{Ward}
Ward is a novel operating system architecture which is resilient to transient execution attacks, yet avoids many of the expensive software mitigations that existing operating systems employ when running on older processors. 

In Ward, the operating system kernel is divided into multiple domains.
The K-domain includes all information accessible to the operation system, while each process has its own associated Q-domain consisting only of the userspace memory and kernel space data structures related to that one process.
At any given point in time the processor is either executing in userspace, in a Q-domain, or in the K-domain. 

Notably when executing in a Q-domain, Ward is able to avoid many of the expensive software mitigations that would ordinarily be required by a conventional OS when running in kernel mode on processors vulnerable to Spectre and Meltdown.
And since Ward is able to handle many system calls and traps entirely in the Q-domain, it can achieve considerably better performance on many workloads compared to conventional operating system designs.

% \section{Contributions}

% \begin{itemize}
%     \item
% \end{itemize}

% There are also several limitations.


\section{Outline}
The following chapter presents an end-to-end performance evaluation, and then goes into detail on each major attack describing both background on how it works as well as analyzing its impact on each evaluated system.
We then proceed to introduce the Unmapped Speculation Contract which encapsulates some security guarantees that we believe even old/vulnerable processors are able to provide, and describe the Ward kernel design that is able to leverage it to improve the performance of OS intensive workloads.
Afterwards is an overview of related work in this space.
We follow up with some discussion, some ideas for future work, and then conclude.
